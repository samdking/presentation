<!doctype html>
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="assets/style.css" />
	</head>
	<body>
		
		<div class="slide" id="slide-1">
			<h1 class="big">GIT IS GOOD</h1>
		</div>
		
		<div class="slide" id="slide-2">
			<h2>Three important parts of Git:</h2>
			<ol class="loud">
				<li>The HEAD: a pointer to your last commit</li>
				<li>The Index: stage for your next commit</li>
				<li>Working Directory: your files</li>
			</ol>
		</div>

		<div class="slide" id="slide-3">
			<h2>Modifying your working directory</h2>
			<p class="detail">By editing, adding and deleting files, you modify your working directory. When this happens, Git notices your working directory is now different to HEAD, and suggests you stage the changes for committing.</p>
			<ul>
				<li>Editing, adding, deleting files = modifying your working directory</li>
				<li>If working directory different to HEAD - git suggests you stage your changes</li>
			</ul>
			<pre># Changes not staged for commit:
#
#	<span style="color:red">modified:   assets/style.css</span></pre>
		</div>

		<div class="slide" id="slide-4">
			<h2><span class="cmd">git add</span></h2>
			<p class="detail">Git add (and also git rm and git mv) modify the index. GIT will then report that the <em>index</em> is different to HEAD, and ask you to create a new commit of the changes (moving the HEAD on).</p>
			<ul>
				<li>git add, git rm and git mv modify your index</li>
				<li>If index different to HEAD - git suggests you create a new commit.</li>
			</ul>

			<pre># Changes to be committed:
#
#	<span style="color: green">modified:   assets/style.css</span></pre>
		</div>

		<div class="slide" id="slide-5">
			<h2><span class="cmd">git commit</h2>
			<ul>
				<li>Commit will add a new commit and move the HEAD pointer to that new commit.</li>
			</ul>
			<pre>[master b5d5aeb] My awesome commit
 1 files changed, 3 insertions(+), 1 deletions(-)</pre>
 			<ul>
 				<li>HEAD now points to <span class="cmd">b5d5aeb</span></li>
 			</ul>
		</div>

		<div class="slide" id="slide-6">
			<h2><span class="cmd">reset or checkout?</span></h2>
			<p><strong><span class="cmd">Checkout</span> offers an alternative view of your repository and its history.</strong> When you checkout, HEAD moves to another branch or commit.
			<p><strong><span class="cmd">Reset</span> rewrites your history, allowing you to pretend part of your repository   didn't happen.</strong> When you reset, your history moves, leaving HEAD pointing to a different commit.
		</div>

		<div class="slide" id="slide-7">
			<h2><span class="cmd">git reset --soft</span></h2>
			<h2><span class="cmd">git reset <span>--mixed</span></span></h2>
			<h2><span class="cmd">git reset --hard</span></h2>
		</div>

		<div class="slide" id="slide-8">
			<h2><span class="cmd">git reset HEAD</span></h2>
			<p class="detail">HEAD points to the last snapshop, the current commit you are on. Resetting the HEAD will simply discard any staged changes in your index. A <span class="cmd">--mixed</span> reset (the default) does this, whilst preserving your working directory.</p>
			<p class="detail">A <span class="cmd">--hard</span> flag is more destructive, and will throw away any changes in your working directory, back to your last commit (HEAD).</p>
			<ul>
				<li>HEAD points to the last snapshot</li>
				<li>Resetting HEAD discards any staged changes in the index</li>
				<li>A <span class="cmd">--mixed</span> reset (default) will preserve your working directory</li>
				<li>A <span class="cmd">--hard</span> flag throws away any changes in your working directory</li>
			</ul>
		</div>

		<div class="slide" id="slide-9">
			<h3><span class="cmd">git reset HEAD~1 --soft</span></h3>
			<p>Moves HEAD back one commit, preserving the comitted files in the index.</p>
			<h3><span class="cmd">git reset 9e5e64a</span></h3>
			<p>Moves HEAD to a specific commit</p>
			<h3><span class="cmd">git reset branch</span></h3>
			<p>Moves HEAD to commit, identified by a branch</p>
		</div>

		<div class="slide" id="slide-10">
			<h3>Deploying live</h3>
			<ul>
				<li>When pushing to the live repository, you add commits, updating the HEAD</li>
				<li>However, unless prompted, GIT will not update the working directory.</li>
				<li>Hence the need for a post-receive hook</li>
				<li>This runs <span class="cmd">git reset HEAD --hard</span></li>
			</ul>
		</div>

		<div class="slide" id="slide-11">
			<h2><span class="cmd">git checkout</span></h2>
			<p class="detail">Git checkout will always modify your working directory - you're <em>checking out</em> code changes so you can work on them.</p>
			<p class="detail">HEAD moves to point to a different commit. You are not changing anything, you're just moving around your repository. Checkout won't lose any of your changes.</p>
			<p class="detail">Checking out a commit hash means you are no longer on a branch, putting you in "Detached Head State". This is what Git is doing behind the scenes when updating a submodule.</p>
			<ul>
				<li>Always modified your working directory</li>
				<li>HEAD pointer moves to different commit.</li>
				<li>Nothing changes, you just move around your repository.</li>
				<li>Won't lose any changes</li>
				<li>If you Checkout a commit hash, you'll have a "detached head"</li>
				<li>This is what a submodule update does</li>
		</div>

		<div class="slide" id="slide-12">
			<h3><span class="cmd">git checkout my-branch</span></h3>
			<p>Checkout the branch my-branch</p>
			<h3><span class="cmd">git checkout master~5 index.php</span></h3>
			<p>Checkout the state of index.php, 5 commits ago on the master branch</p>
			<h3><span class="cmd">git checkout -- test.php</span></h3>
			<p>Reverts current changes in a file, back to what it was in HEAD</p>
		</div>

		<div class="slide" id="slide-13">
			<h2><span class="cmd">git submodule update</span></h2>
			<ul>
				<li>Update the commit of a submodule to match what the master repository says it should be on.</li>
				<li>Master project does not care about anything in the sub repository, other than the commit it should be pointing at.</li>
				<li>If you master repository detects it should be on a different commit to what the submodule is on, Git will tell you the submodule has "new commits" and needs to be updated.</li>
			</ul>
		</div>

		<div class="slide" id="slide-14">
			<h2>A detached HEAD</h2>
			<p class="detail">When you update a submodule, That repository is no longer pointing at a branch, it is pointing directly to a commit. You can make further commits in this state, however since there is no branch referencing it, it's easy to get lost.</p>
			<p class="detail">If you want to make a commit in a submodule, checkout the relevant branch, merge in the remote changes, and you're good to go.</p>
			<ul>
				<li>When you update a submodule, the repo is no longer pointing at a branch</li>
				<li>Detached head mode</li>
				<li>Easy for commits to be lost since there is no referenced branch</li>
				<li>To commit in a submodule, checkout a branch and commit on this.</li>
			</ul>
		</div>

		<div class="slide" id="slide-15">
			<h2>Branching</h2>
			<ul>
				<li>Go off in another direction, from a base commit</li>
				<li>The commit at which you branched off at is used when merging back in</li>
				<li>When merging back in to a base branch (e.g. master or develop), if nothing has changed, the base branch "fast-forwards" to your branch's commit.</li>
			</ul>
			<pre>$ git merge hotfix
Updating f42c576..3a0874c
Fast forward
 README |    1 <span style="color: red">-</span>
 1 files changed, 0 insertions(+), 1 deletions(-)</pre>
			<ul>
				<li>If base branch has diverged, it will do a recursive merge, creating a merge commit.</li>
			</ul>
		</div>

		<div class="slide" id="slide-16">
			<h2>Rebasing</h2>
			<ul>
				<li>One way to avoid a recursive merge is to rebase.</li>
				<li>This replays your commits on top of the merged in commits.</li>
			</ul>
			<pre>$ git branch
* <span style="color: green">develop</span>
  master
$ git rebase origin/develop
First, rewinding head to replay your work on top of it...
Applying: Updated CMS</pre>
			<ul>
				<li>Your commits will end up after those merged in, as if you'd merged initially.</li>
			</ul>
		</div>

		<nav>
			<a href="#slide-1">1</a>
			<a href="#slide-2">2</a>
			<a href="#slide-3">3</a>
			<a href="#slide-4">4</a>
			<a href="#slide-5">5</a>
			<a href="#slide-6">6</a>
			<a href="#slide-7">7</a>
			<a href="#slide-8">8</a>
			<a href="#slide-9">9</a>
			<a href="#slide-10">10</a>
			<a href="#slide-11">11</a>
			<a href="#slide-12">12</a>
			<a href="#slide-13">13</a>
			<a href="#slide-14">14</a>
			<a href="#slide-15">15</a>
			<a href="#slide-16">16</a>
		</nav>

	</body>
</html>